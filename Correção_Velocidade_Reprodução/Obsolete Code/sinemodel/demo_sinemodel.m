%% Sinewave and Sinusoid+Noise Analysis/Synthesis in Matlab
%
% Many sounds of importance to human listeners have a
% pseudo-periodic structure, that is over certain stretches of
% time, the waveform is a slightly-modified copy of what it was
% some fixed time earlier, where this fixed time period is
% typically in the range of 0.2 - 10 ms, corresponding to a
% fundamental frequency of 100 Hz - 5 kHz, usually giving rise to a
% corresponding pitch percept. 
% 
% Periodic signals can be approximated by a sum of sinusoids whose
% frequencies are integer multiples of the fundamental frequency
% and whose magnitudes and phases can be uniquely determined to
% match the signal - so-called Fourier analysis. One manifestation
% of this is the spectrogram, which shows short-time Fourier
% transform magnitude as a function of time. A narrowband
% spectrogram (i.e. one produced with a short-time window longer
% than the fundamental period of the sound) will reveal a series of
% nearly-horizontal, uniformly-spaced energy ridges, corresponding
% to the sinusoidal Fourier components or harmonics that are an
% equivalent representation of the sound waveform. Below is a
% spectrogram of a brief clarinet melody; the harmonics are clearly
% defined. 
%
% The key idea behind sinewave modeling is to represent each one of
% those ridges explicitly and separately as a set of frequency and
% magnitude values. The resulting sinusiod tracks can be
% resynthesized by using them as control parameters to a sinewave
% oscillator. Resynthesis can be complete or partial, and can be
% modified for instance by stretching in time and frequency, or by
% some more unusual technique. 

%% Sinewave analysis
% Sinewave analysis is in concept quite simple: Form the short-time
% Fourier transform magnitude (as shown in the spectrogram below),
% find the frequencies and magnitudes of the spectral peaks at each
% time step, thread them together, and you've got your
% representation. 

[d,sr] = audioread('audiochirp1.wav');
subplot(211)
specgram(d,512,sr);
title('Original clar.wav');

%%
% In practice, it gets a little complicated for a couple of
% reasons. Firstly, picking peaks is sometimes difficult: if
% there's a very slight local maximum on the 'shoulder' of a bigger
% peak, does that count or not? Also, the resolution of the STFT is
% typically not all that good (perhaps 128 bins spanning 4 kHz, or
% about 30 Hz), so you need to interpolate the maximum in both
% frequency and magnitude. However, this basically works. 
%
% [R,M]=<extractrax.m extractrax>(S,T) does this tracking stage
% (see below for explanation of arguments). It actually has some
% fairly complex heuristics internally to decide when a track's
% magnitude suggests that a new track should be formed, but it
% works well in many cases. Usage is as below; 

[d,sr] = audioread('audiochirp1.wav');
S = specgram(d,256);          % SP Toolbox routine (or use ifgram.m below)
[R,M]=extractrax(abs(S));     % find peaks in STFT *magnitude*
disp(['size of R is ',num2str(size(R,1)),' rows x ',num2str(size(R,2)),' cols']);
tt = (1:224)*128/sr;           % default specgram step is NFFT/2 i.e. 128
F = R*sr/256;                  % Convert R from bins to Hz
specgram(d,256,sr)
colormap(1-gray)              % black is intense, white is quiet
hold on
plot(tt,F','r');              % the tracks follow the specgram peaks

%%
% Notice that a few tracks have picked up the 'non-harmonic'
% sinusoids between the main harmonics. These, I think, are
% transient resonances at an octave below the main note. If we were
% doing strictly harmonic analysis, these would be excluded. 
% 
% The R and M matrices returned by extractrax.m have one row for
% each track generated by the system, and one column for each time
% frame in the original spectrogram. A given track is defined by
% the corresponding row from each matrix. Most tracks will only
% exist for a subset of the time steps, so their magnitudes are set
% to zero and their frequencies are set to NaN for the steps where
% they don't exist (using NaN allows the plotting trick above,
% since NaN values are discarded by plot()). 